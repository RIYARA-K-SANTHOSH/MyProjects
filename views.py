from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from .models import UserProfile, Profile,AdditionalProfile,Family,HobbiesAndLifestyle, ShortlistedProfile

from django.shortcuts import render
from .models import UserProfile

def home(request):
    search_results = None
    if request.method == 'GET' and 'search_id' in request.GET:
        search_id = request.GET.get('search_id', '').upper()
        if search_id:
            search_results = UserProfile.objects.filter(connect_id=search_id)
    return render(request, 'index.html', {'search_results': search_results})
# Registration View
def register(request):
    if request.method == 'POST':
        try:
            # Get form data
            full_name = request.POST.get('fullname')
            age = request.POST.get('age')
            gender = request.POST.get('gender')
            phone = request.POST.get('phone')
            email = request.POST.get('email')
            password = request.POST.get('password')

            # Basic validation
            if not all([full_name, age, gender, phone, email, password]):
                messages.error(request, "All fields are required")
                return render(request, 'register.html', {'form_data': request.POST})

            # Create user - connect_id will be auto-generated by the save() method
            user = UserProfile(
                full_name=full_name,
                age=int(age),
                gender=gender,
                phone=phone,
                email=email,
                password=password  # Remember: In production, use proper password hashing
            )
            user.save()  # This will trigger the save() method and generate connect_id
            
            return redirect('profile', connect_id=user.connect_id)

        except Exception as e:
            messages.error(request, f"Registration failed: {str(e)}")
            return render(request, 'register.html', {'form_data': request.POST})
    
    return render(request, 'register.html')

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from .models import UserProfile, Profile

def profile_view(request, connect_id):
    user = get_object_or_404(UserProfile, connect_id=connect_id)
    
    # Get or create profile for this user
    profile, created = Profile.objects.get_or_create(user=user)
    
    if request.method == 'POST':
        try:
            # Update profile with form data
            profile.height = request.POST.get('height') or None
            profile.complexion = request.POST.get('complexion') or None
            profile.body_type = request.POST.get('body_type') or None
            profile.physical_status = request.POST.get('physical_status') or None
            profile.marital_status = request.POST.get('marital_status') or None
            profile.family_status = request.POST.get('family_status') or None
            profile.denomination = request.POST.get('denomination') or None
            profile.parish_name = request.POST.get('parish_name') or None
            profile.parish_place = request.POST.get('parish_place') or None
            profile.save()
        
            return redirect('education', connect_id=user.connect_id)
        
        except Exception as e:
            messages.error(request, f"Error updating profile: {str(e)}")
    
    # For GET requests, show the form with existing data
    context = {
        'user': user,
        'profile': profile,
        'height_choices': Profile.HEIGHT_CHOICES,
        'complexion_choices': Profile.COMPLEXION_CHOICES,
        'body_type_choices': Profile.BODY_TYPE_CHOICES,
        'physical_status_choices': Profile.PHYSICAL_STATUS_CHOICES,
        'marital_status_choices': Profile.MARITAL_STATUS_CHOICES,
        'family_status_choices': Profile.FAMILY_STATUS_CHOICES,
        'denomination_choices': Profile.DENOMINATION_CHOICES,
    }
    return render(request, 'profile.html', context)
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from .models import UserProfile, EducationProfessional

def education_view(request, connect_id):
    user = get_object_or_404(UserProfile, connect_id=connect_id)
    
    # Get or create education/professional record
    education_professional, created = EducationProfessional.objects.get_or_create(user=user)
    
    if request.method == 'POST':
        try:
            # Process education data
            education_professional.education_level = request.POST.get('education_level')
            
            # Bachelor's details
            if education_professional.education_level == 'bachelors':
                education_professional.bachelors_degree = request.POST.get('bachelors_degree')
                education_professional.bachelors_specialization = request.POST.get('bachelors_specialization')
                education_professional.bachelors_institution = request.POST.get('bachelors_institution')
            
            # Master's details
            elif education_professional.education_level == 'masters':
                education_professional.masters_degree = request.POST.get('masters_degree')
                education_professional.masters_specialization = request.POST.get('masters_specialization')
                education_professional.masters_institution = request.POST.get('masters_institution')
            
            # PhD details
            elif education_professional.education_level == 'phd':
                education_professional.phd_field = request.POST.get('phd_field')
                education_professional.phd_institution = request.POST.get('phd_institution')
            
            # Other education
            elif education_professional.education_level == 'other':
                education_professional.other_education = request.POST.get('other_education')
            
            # Process professional data
            education_professional.occupation = request.POST.get('occupation')
            education_professional.employment_type = request.POST.get('employment_type')
            education_professional.working_country = request.POST.get('working_country')
            education_professional.working_state = request.POST.get('working_state')
            education_professional.working_district = request.POST.get('working_district')
            education_professional.working_city = request.POST.get('working_city')
            education_professional.annual_income = request.POST.get('annual_income')
            
            education_professional.save()
            return redirect('contact', connect_id=user.connect_id)
            
        except Exception as e:
            messages.error(request, f'Error saving information: {str(e)}')
    
    # Prepare context with all choices
    context = {
        'user': user,
        'education_professional': education_professional,
        'education_levels': EducationProfessional.EDUCATION_LEVELS,
        'bachelors_degrees': EducationProfessional.BACHELORS_DEGREES,
        'masters_degrees': EducationProfessional.MASTERS_DEGREES,
        'occupation_choices': EducationProfessional.OCCUPATION_CHOICES,
        'employment_choices': EducationProfessional.EMPLOYMENT_CHOICES,
        'income_choices': EducationProfessional.INCOME_CHOICES,
    }
    
    return render(request, 'education.html', context)

def contact_view(request, connect_id):
    user = get_object_or_404(UserProfile, connect_id=connect_id)
    additional_profile, created = AdditionalProfile.objects.get_or_create(user=user)
    
    if request.method == 'POST':
        try:
            # Process native location data
            additional_profile.native_country = request.POST.get('native_country')
            
            # Only process state/city if country is not "other"
            if additional_profile.native_country != 'other':
                additional_profile.native_state = request.POST.get('native_state')
                additional_profile.native_city = request.POST.get('native_city')
            else:
                additional_profile.native_state = None
                additional_profile.native_city = None
            
            # Process contact information
            additional_profile.whatsapp_code = request.POST.get('whatsapp_code')
            additional_profile.whatsapp_number = request.POST.get('whatsapp_number')
            additional_profile.mobile_code = request.POST.get('mobile_code')
            additional_profile.mobile_number = request.POST.get('mobile_number')
            additional_profile.address = request.POST.get('address')
            additional_profile.pincode = request.POST.get('pincode')
            
            additional_profile.save()
            return redirect('profilecreate',connect_id=user.connect_id)  # Changed to redirect to profilecreate
            
        except Exception as e:
            messages.error(request, f'Error saving contact information: {str(e)}')
    
    # Prepare context with choices
    context = {
        'user': user,
        'additional_profile': additional_profile,
    }
    
    return render(request, 'contact.html', context)
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from .models import UserProfile, ProfileCreationDetails

def profilecreate_view(request, connect_id):
    user = get_object_or_404(UserProfile, connect_id=connect_id)
    
    # Initialize form data and errors
    form_data = {
        'created_by': '',
        'creator_name': '',
        'hear_about': ''
    }
    form_errors = {}
    
    try:
        creation_details = ProfileCreationDetails.objects.get(user=user)
        form_data = {
            'created_by': creation_details.created_by,
            'creator_name': creation_details.creator_name,
            'hear_about': creation_details.hear_about
        }
    except ProfileCreationDetails.DoesNotExist:
        creation_details = None

    if request.method == 'POST':
        created_by = request.POST.get('created_by', '').strip()
        creator_name = request.POST.get('creator_name', '').strip()
        hear_about = request.POST.get('hear_about', '').strip()
        
        # Validate fields
        valid = True
        if not created_by:
            form_errors['created_by'] = 'This field is required'
            valid = False
        if not creator_name:
            form_errors['creator_name'] = 'This field is required'
            valid = False
        if not hear_about:
            form_errors['hear_about'] = 'This field is required'
            valid = False
            
        if not valid:
            # Update form_data with POST values if validation fails
            form_data = {
                'created_by': created_by,
                'creator_name': creator_name,
                'hear_about': hear_about
            }
            messages.error(request, 'Please correct the errors below')
        else:
            try:
                if creation_details:
                    # Update existing record
                    creation_details.created_by = created_by
                    creation_details.creator_name = creator_name
                    creation_details.hear_about = hear_about
                else:
                    # Create new record
                    creation_details = ProfileCreationDetails(
                        user=user,
                        created_by=created_by,
                        creator_name=creator_name,
                        hear_about=hear_about
                    )
                
                creation_details.save()
                return redirect('mainpage', connect_id=user.connect_id)
                
            except Exception as e:
                messages.error(request, f'Error saving details: {str(e)}')

    context = {
        'user': user,
        'form_data': form_data,
        'form_errors': form_errors,
        'CREATED_BY_CHOICES': ProfileCreationDetails.CREATED_BY_CHOICES,
        'HEAR_ABOUT_CHOICES': ProfileCreationDetails.HEAR_ABOUT_CHOICES,
    }
    return render(request, 'profilecreate.html', context)

from django.shortcuts import render, redirect
from django.contrib import messages
from .models import UserProfile

def login_view(request):
    if request.method == 'POST':
        username = request.POST.get('username')
        password = request.POST.get('password')
        
        # Check for admin login first
        if username == 'admin@gmail.com' and password == 'admin123':
            request.session['is_admin'] = True
            return redirect('admin_page')  # Redirect to admin dashboard
        
        # Regular user authentication
        user = None
        
        # Check if input is email
        if '@' in username:
            try:
                user = UserProfile.objects.get(email=username)
            except UserProfile.DoesNotExist:
                pass
        
        # Check if input is phone number (basic check)
        elif username.isdigit():
            try:
                user = UserProfile.objects.get(phone=username)
            except UserProfile.DoesNotExist:
                pass
        
        # Check if input is CONNECTID
        elif username.upper().startswith('CONNECTID'):
            try:
                user = UserProfile.objects.get(connect_id=username.upper())
            except UserProfile.DoesNotExist:
                pass
        
        # Verify user and password
        if user and user.password == password:  # Note: In production, use proper password hashing
            # Store user ID in session to mark as logged in
            request.session['user_id'] = user.id
            request.session['connect_id'] = user.connect_id
            return redirect('mainpage', connect_id=user.connect_id)
        
        # If we get here, authentication failed
        messages.error(request, "Invalid credentials. Please try again.")
        return render(request, 'login.html', {'username': username})
    
    # GET request - show login form
    return render(request, 'login.html')

def admin_page(request):
    if not request.session.get('is_admin'):
        return redirect('login_view')
    return render(request, 'admin.html')

from django.shortcuts import render, redirect
from django.contrib import messages
from .models import UserProfile, Profile, EducationProfessional, AdditionalProfile

def myprofile_view(request):
    # Check if user is logged in
    if 'user_id' not in request.session:
        messages.error(request, "Please login to view your profile")
        return redirect('login')
    
    try:
        # Get the logged-in user
        user = UserProfile.objects.get(id=request.session['user_id'])
        
        # Get related profile information
        profile = Profile.objects.get(user=user)
        education = EducationProfessional.objects.get(user=user)
        additional = AdditionalProfile.objects.get(user=user)
        
        context = {
            'user': user,
            'profile': profile,
            'education': education,
            'additional': additional,
        }
        
        return render(request, 'myprofile.html', context)
        
    except UserProfile.DoesNotExist:
        messages.error(request, "User not found")
        return redirect('login')
    except Exception as e:
        messages.error(request, f"Error loading profile: {str(e)}")
        return redirect('login')
    
from django.shortcuts import render, redirect
from django.contrib import messages
from .models import SuccessStory, AdditionalPhoto
from django.core.files.storage import FileSystemStorage
from django.db import transaction
import logging

logger = logging.getLogger(__name__)

def addyourstory_view(request):
    if request.method == 'POST':
        try:
            # Get form data
            brides_name = request.POST.get('brides_name')
            grooms_name = request.POST.get('grooms_name')
            wedding_date = request.POST.get('wedding_date')
            country_code = request.POST.get('country_code', '+91')  # default to +91
            phone_number = request.POST.get('phone_number')
            story = request.POST.get('story')
            cover_photo = request.FILES.get('cover_photo')
            
            # Validate required fields
            if not all([brides_name, grooms_name, wedding_date, phone_number, story, cover_photo]):
                missing_fields = []
                if not brides_name: missing_fields.append("Bride's Name")
                if not grooms_name: missing_fields.append("Groom's Name")
                if not wedding_date: missing_fields.append("Wedding Date")
                if not phone_number: missing_fields.append("Phone Number")
                if not story: missing_fields.append("Story")
                if not cover_photo: missing_fields.append("Cover Photo")
                
                messages.error(request, f'Missing required fields: {", ".join(missing_fields)}')
                return redirect('addyourstory_view')

            # Use transaction to ensure all or nothing gets saved
            with transaction.atomic():
                # Create success story
                success_story = SuccessStory.objects.create(
                    brides_name=brides_name,
                    grooms_name=grooms_name,
                    wedding_date=wedding_date,
                    contact_number=f"{country_code}{phone_number}",
                    story=story,
                    is_approved=False,
                    cover_photo=cover_photo  # assign directly
                )
                
                # Handle additional photos (limit to 5)
                additional_photos = request.FILES.getlist('additional_photos')[:5]
                for photo in additional_photos:
                    AdditionalPhoto.objects.create(
                        success_story=success_story,
                        photo=photo
                    )
       
            return redirect('addyourstory_view')
            
        except Exception as e:
            logger.error(f"Error saving success story: {str(e)}", exc_info=True)
            messages.error(request, 'An error occurred while saving your story. Please try again.')
            return redirect('addyourstory_view')
    
    return render(request, 'addyourstory.html')

from django.shortcuts import render, get_object_or_404
from django.http import JsonResponse
from django.views.decorators.http import require_POST
from .models import SuccessStory

def success_stories_view(request):
    # Get ALL success stories (without approval filter) with their additional photos
    stories = SuccessStory.objects.all()\
                                 .prefetch_related('additional_photos')\
                                 .order_by('-created_at')
    return render(request, 'success_stories.html', {'stories': stories})
from django.shortcuts import render, get_object_or_404
from django.http import JsonResponse
from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt
from .models import SuccessStory, AdditionalPhoto

from django.shortcuts import get_object_or_404
from django.http import JsonResponse
from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt
from .models import SuccessStory, AdditionalPhoto

@require_POST
@csrf_exempt  # Only for testing, remove in production
def approve_story(request, story_id):
    story = get_object_or_404(SuccessStory, id=story_id)
    story.is_approved = True
    story.save()
    return JsonResponse({'success': True})

@require_POST
@csrf_exempt  # Only for testing, remove in production
def reject_story(request, story_id):
    story = get_object_or_404(SuccessStory, id=story_id)
    
    try:
        # Delete all additional photos first (using the correct field name 'success_story')
        AdditionalPhoto.objects.filter(success_story=story).delete()
        
        # Delete the cover photo if it exists
        if story.cover_photo:
            story.cover_photo.delete(save=False)
            
        # Delete the story
        story.delete()
        
        return JsonResponse({'success': True})
    
    except Exception as e:
        return JsonResponse({'success': False, 'error': str(e)}, status=500)



def profilecompletion_view(request, connect_id):
    # Get the user profile by connect_id
    current_user_profile = get_object_or_404(UserProfile, connect_id=connect_id)
    
    # Get the active profile picture if it exists
    profile_picture = ProfilePicture.objects.filter(user=current_user_profile, is_active=True).first()
    
    # Get or create all associated profiles
    profile = Profile.objects.get_or_create(user=current_user_profile)[0]
    education_professional = EducationProfessional.objects.get_or_create(user=current_user_profile)[0]
    family = Family.objects.get_or_create(user=current_user_profile)[0]
    creation_details = ProfileCreationDetails.objects.get_or_create(user=current_user_profile)[0]
    additional_profile = AdditionalProfile.objects.get_or_create(user=current_user_profile)[0]
    hobbies = HobbiesAndLifestyle.objects.get_or_create(user=current_user_profile)[0]
    
    
    # Calculate profile completion percentage
    user_fields = [
        current_user_profile.full_name,
        current_user_profile.age,
        current_user_profile.gender,
        current_user_profile.phone,
        current_user_profile.email,
    ]
    
    profile_fields = [
        profile.height,
        profile.complexion,
        profile.body_type,
        profile.physical_status,
        profile.marital_status,
        profile.family_status,
        profile.denomination,
        profile.parish_name,
        profile.parish_place,
    ]
    
    education_fields = [
        education_professional.education_level,
        education_professional.occupation,
        education_professional.employment_type,
        education_professional.working_country,
        education_professional.working_state,
        education_professional.working_district,
        education_professional.working_city,
        education_professional.annual_income,
    ]
    
    family_fields = [
        family.family_status,
        family.father_name,
        family.mother_name,
        family.no_of_brothers,
        family.no_of_sisters,
    ]
    
    creation_fields = [
        creation_details.created_by,
        creation_details.creator_name,
    ]
    
    additional_fields = [
        additional_profile.native_country,
        additional_profile.native_state,
        additional_profile.native_city,
        additional_profile.address,
    ]
    
    hobbies_fields = [
        hobbies.hobbies,
        hobbies.eating_habits,
        hobbies.drinking_habits,
        hobbies.smoking_habits,
    ]
    
    
    
    # Add profile picture to completion calculation if you want
    picture_field = [profile_picture] if profile_picture else []
    
    total_fields = (len(user_fields) + len(profile_fields) + 
                   len(education_fields) + len(family_fields) + 
                   len(creation_fields) + len(additional_fields) )
             
    # Add +1 to total_fields if you want to include profile picture in completion
    
    filled_fields = (
        sum(1 for field in user_fields if field) + 
        sum(1 for field in profile_fields if field) + 
        sum(1 for field in education_fields if field) +
        sum(1 for field in family_fields if field) +
        sum(1 for field in creation_fields if field) +
        sum(1 for field in additional_fields if field) +
        sum(1 for field in hobbies_fields if field) 
    )
    # Add +1 to filled_fields if profile_picture exists and you want to include it
    
    completion_percentage = int((filled_fields / total_fields) * 100) if total_fields > 0 else 0
    
    context = {
        'current_user': current_user_profile,
        'profile': profile,
        'education_professional': education_professional,
        'family': family,
        'creation_details': creation_details,
        'additional_profile': additional_profile,
        'hobbies': hobbies,
        'completion_percentage': completion_percentage,
        'profile_picture': profile_picture,  # Add profile picture to context
    }
    return render(request, 'profilecompletion.html', context)

# views.py
from django.shortcuts import render, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from datetime import datetime
from .models import UserProfile, Profile

def edit_primary_info(request, connect_id):
    user_profile = get_object_or_404(UserProfile, connect_id=connect_id)
    profile = user_profile.profile
    
    if request.method == 'POST':
        try:
            # Update UserProfile fields
            user_profile.full_name = request.POST.get('full_name', user_profile.full_name)
            user_profile.gender = request.POST.get('gender', user_profile.gender)
            
            # Handle date of birth conversion
            dob_str = request.POST.get('date_of_birth')
            if dob_str:
                try:
                    user_profile.date_of_birth = datetime.strptime(dob_str, '%Y-%m-%d').date()
                except ValueError:
                    messages.error(request, "Invalid date format. Please use YYYY-MM-DD.")
                    return redirect('edit_primary_info', connect_id=connect_id)
            
            # Handle numeric fields
            try:
                weight = request.POST.get('weight')
                user_profile.weight = int(weight) if weight else None
            except ValueError:
                messages.error(request, "Weight must be a number")
                return redirect('edit_primary_info', connect_id=connect_id)
            
            # Update other fields
            user_profile.blood_group = request.POST.get('blood_group', '')
            user_profile.mother_tongue = request.POST.get('mother_tongue', '')
            user_profile.about_me = request.POST.get('about_me', '')
            
            # Update Profile fields
            try:
                height = request.POST.get('height')
                profile.height = int(height) if height else None
            except ValueError:
                messages.error(request, "Invalid height value")
                return redirect('edit_primary_info', connect_id=connect_id)
            
            profile.complexion = request.POST.get('complexion', '')
            profile.body_type = request.POST.get('body_type', '')
            profile.marital_status = request.POST.get('marital_status', '')
            profile.physical_status = request.POST.get('physical_status', '')
            
            # Save both models
            user_profile.save()
            profile.save()
            
            return redirect('profilecompletion', connect_id=connect_id)
            
        except Exception as e:
            messages.error(request, f"Error updating profile: {str(e)}")
            return redirect('edit_primary_info', connect_id=connect_id)
    
    context = {
        'current_user': user_profile,
        'profile': profile,
        'connect_id': connect_id,
    }
    return render(request, 'edit_primary_info.html', context)
from django.shortcuts import render, redirect, get_object_or_404
from .models import HobbiesAndLifestyle, UserProfile
from django.contrib.auth.decorators import login_required

def edit_hobbies_lifestyle(request, connect_id):
    user_profile = get_object_or_404(UserProfile, connect_id=connect_id)
    
    # Add your permission check here if needed
    # For example, if you want to check if the logged-in user owns this profile
    # You'll need to implement whatever logic connects UserProfile to auth user
    
    hobbies, created = HobbiesAndLifestyle.objects.get_or_create(user=user_profile)
    
    if request.method == 'POST':
        # Update all fields from the POST data
        hobbies.hobbies = request.POST.get('hobbies', '').strip() or None
        hobbies.favorite_music = request.POST.get('favorite_music', '').strip() or None
        hobbies.preferred_books = request.POST.get('preferred_books', '').strip() or None
        hobbies.preferred_movies = request.POST.get('preferred_movies', '').strip() or None
        hobbies.sports_games = request.POST.get('sports_games', '').strip() or None
        hobbies.favorite_cuisine = request.POST.get('favorite_cuisine', '').strip() or None
        hobbies.spoken_languages = request.POST.get('spoken_languages', '').strip() or None
        hobbies.cultural_background = request.POST.get('cultural_background', '').strip() or None
        
        # Update choice fields
        hobbies.eating_habits = request.POST.get('eating_habits') or None
        hobbies.drinking_habits = request.POST.get('drinking_habits') or None
        hobbies.smoking_habits = request.POST.get('smoking_habits') or None
        
        hobbies.save()
        return redirect('profilecompletion', connect_id=connect_id)
    
    context = {
         'current_user': user_profile,
        'hobbies': hobbies,
        'connect_id': connect_id,
        'eating_habits_choices': HobbiesAndLifestyle.EATING_HABITS_CHOICES,
        'habit_choices': HobbiesAndLifestyle.HABIT_CHOICES,
    }
    return render(request, 'edit_hobbies_lifestyle.html', context)



def edit_family_info(request, connect_id):
    user_profile = get_object_or_404(UserProfile, connect_id=connect_id)
    family, created = Family.objects.get_or_create(user=user_profile)
    
    if request.method == 'POST':
        # Update all fields from POST data
        family.family_status = request.POST.get('family_status') or None
        family.father_name = request.POST.get('father_name') or None
        family.father_housename = request.POST.get('father_housename') or None
        family.father_native_place = request.POST.get('father_native_place') or None
        family.father_occupation = request.POST.get('father_occupation') or None
        family.mother_name = request.POST.get('mother_name') or None
        family.mother_housename = request.POST.get('mother_housename') or None
        family.mother_native_place = request.POST.get('mother_native_place') or None
        family.mother_occupation = request.POST.get('mother_occupation') or None
        
        # Siblings information
        family.no_of_brothers = int(request.POST.get('no_of_brothers', 0))
        family.no_of_brothers_married = int(request.POST.get('no_of_brothers_married', 0))
        family.no_of_brothers_unmarried = int(request.POST.get('no_of_brothers_unmarried', 0))
        family.no_of_brothers_priest = int(request.POST.get('no_of_brothers_priest', 0))
        
        family.no_of_sisters = int(request.POST.get('no_of_sisters', 0))
        family.no_of_sisters_married = int(request.POST.get('no_of_sisters_married', 0))
        family.no_of_sisters_unmarried = int(request.POST.get('no_of_sisters_unmarried', 0))
        family.no_of_sisters_nun = int(request.POST.get('no_of_sisters_nun', 0))
        
        # Other fields
        family.asset_details = request.POST.get('asset_details') or None
        family.about_family = request.POST.get('about_family') or None
        
        family.save()

        return redirect('profilecompletion', connect_id=connect_id)
    
    context = {
         'current_user': user_profile,
        'family': family,
        'connect_id': connect_id,
        'family_status_choices': Family.FAMILY_STATUS_CHOICES,
        'occupation_choices': Family.OCCUPATION_CHOICES,
    }
    return render(request, 'edit_family_info.html', context)
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from .models import AdditionalProfile, UserProfile

def edit_contact_info(request, connect_id):
    # Get the user profile and additional profile
    user_profile = get_object_or_404(UserProfile, connect_id=connect_id)
    additional_profile = get_object_or_404(AdditionalProfile, user=user_profile)
    
    if request.method == 'POST':
        # Update mobile number fields
        additional_profile.mobile_code = request.POST.get('mobile_code')
        additional_profile.mobile_number = request.POST.get('mobile_number')
        
        # Update WhatsApp fields
        additional_profile.whatsapp_code = request.POST.get('whatsapp_code')
        additional_profile.whatsapp_number = request.POST.get('whatsapp_number')
        
        # Update other contact fields
        additional_profile.secondary_mobile = request.POST.get('secondary_mobile')
        additional_profile.secondary_mobile_code = request.POST.get('secondary_mobile_code')
        additional_profile.landline_number = request.POST.get('landline_number')
        additional_profile.alternate_email = request.POST.get('alternate_email')
        additional_profile.preferred_contact_time = request.POST.get('preferred_contact_time')
        
        # Update address fields
        additional_profile.address = request.POST.get('address')
        additional_profile.pincode = request.POST.get('pincode')
        
        # Handle present address
        present_address_type = request.POST.get('present_address_type', 'same')
        additional_profile.present_address_type = present_address_type
        if present_address_type == 'different':
            additional_profile.present_address = request.POST.get('present_address')
            additional_profile.present_pincode = request.POST.get('present_pincode')
        else:
            additional_profile.present_address = ''
            additional_profile.present_pincode = ''
        
        # Handle permanent address
        permanent_address_type = request.POST.get('permanent_address_type', 'same')
        additional_profile.permanent_address_type = permanent_address_type
        if permanent_address_type == 'different':
            additional_profile.permanent_address = request.POST.get('permanent_address')
            additional_profile.permanent_pincode = request.POST.get('permanent_pincode')
        else:
            additional_profile.permanent_address = ''
            additional_profile.permanent_pincode = ''
        
        # Save the changes
        additional_profile.save()
        
        # Update user email fields if needed
        user_profile.email = request.POST.get('email')
        user_profile.alternate_email = request.POST.get('alternate_email')
        user_profile.save()
        
       
        return redirect('profilecompletion', connect_id=connect_id)
    
    context = {
        'current_user': user_profile,
        'additional_profile': additional_profile,
        'connect_id': connect_id,
    }
    return render(request, 'edit_contact_info.html', context)

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from .models import UserProfile, ProfilePicture
from django.conf import settings
import os
import base64
import cv2
import numpy as np
from django.core.files.base import ContentFile
from .age_gender_predictor import AgeGenderPredictor
from django.http import JsonResponse
from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt
import json

def uploadphoto_view(request, connect_id):
    user = get_object_or_404(UserProfile, connect_id=connect_id)
    
    if request.method == 'POST':
        # Check if we have a cropped image data
        cropped_image_data = request.POST.get('cropped_image_data')
        analysis_results = None
        
        if cropped_image_data:
            try:
                # Handle base64 image data
                format, imgstr = cropped_image_data.split(';base64,') 
                ext = format.split('/')[-1]  # Get file extension
                
                # Validate extension
                if ext.lower() not in ['jpeg', 'jpg', 'png']:
                    messages.error(request, "Invalid image format")
                    return redirect('uploadphoto', connect_id=connect_id)
                
                # Decode the image
                image_file = ContentFile(base64.b64decode(imgstr), name=f'cropped.{ext}')
                
                # Convert to OpenCV format for analysis
                nparr = np.frombuffer(base64.b64decode(imgstr), np.uint8)
                img_np = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
                
                # Analyze for age and gender
                predictor = AgeGenderPredictor()
                analysis_results = predictor.predict(img_np)
                
                if not analysis_results:
                    messages.warning(request, "No faces detected in the image")
                    return redirect('uploadphoto', connect_id=connect_id)
                
                # Get the first face result (assuming single profile picture)
                result = analysis_results[0]
                
                # Deactivate any existing active profile picture
                ProfilePicture.objects.filter(user=user, is_active=True).update(is_active=False)
                
                # Create new profile picture with cropped image
                new_picture = ProfilePicture(
                    user=user,
                    image=image_file,
                    gender=result['gender'],
                    age=result['age']
                )
                new_picture.save()
                
                messages.success(request, f"Profile picture updated! Detected: {result['gender']}, Age: {result['age']}")
                return redirect('mainpage', connect_id=connect_id)
                
            except Exception as e:
                messages.error(request, f"Error processing image: {str(e)}")
                return redirect('uploadphoto', connect_id=connect_id)
        
        # Fallback to regular file upload if no cropped data
        elif request.FILES.get('profile_picture'):
            try:
                # Read the uploaded file for analysis
                file_bytes = request.FILES['profile_picture'].read()
                nparr = np.frombuffer(file_bytes, np.uint8)
                img_np = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
                
                # Analyze for age and gender
                predictor = AgeGenderPredictor()
                analysis_results = predictor.predict(img_np)
                
                if not analysis_results:
                    messages.warning(request, "No faces detected in the image")
                    return redirect('uploadphoto', connect_id=connect_id)
                
                # Get the first face result
                result = analysis_results[0]
                
                # Reset file pointer after reading
                request.FILES['profile_picture'].seek(0)
                
                # Deactivate any existing active profile picture
                ProfilePicture.objects.filter(user=user, is_active=True).update(is_active=False)
                
                # Create new profile picture
                new_picture = ProfilePicture(
                    user=user,
                    image=request.FILES['profile_picture'],
                    gender=result['gender'],
                    age=result['age']
                )
                new_picture.save()
                
                messages.success(request, f"Profile picture updated! Detected: {result['gender']}, Age: {result['age']}")
                return redirect('mainpage', connect_id=connect_id)
                
            except Exception as e:
                messages.error(request, f"Error uploading image: {str(e)}")
                return redirect('uploadphoto', connect_id=connect_id)
                
        else:
            messages.error(request, "Please select an image to upload")
            return redirect('uploadphoto', connect_id=connect_id)
    
    return render(request, 'uploadphoto.html', {'connect_id': connect_id})

@csrf_exempt
@require_POST
def analyze_image(request):
    try:
        image_data = request.POST.get('image_data')
        if not image_data:
            return JsonResponse({'success': False, 'error': 'No image data provided'})
        
        # Extract base64 data
        format, imgstr = image_data.split(';base64,')
        ext = format.split('/')[-1]
        
        # Convert to OpenCV format
        nparr = np.frombuffer(base64.b64decode(imgstr), np.uint8)
        img_np = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
        
        # Analyze image
        predictor = AgeGenderPredictor()
        results = predictor.predict(img_np)
        
        if not results:
            return JsonResponse({'success': False, 'error': 'No faces detected'})
        
        # Convert numpy arrays to lists for JSON serialization
        serializable_results = []
        for result in results:
            serializable_results.append({
                'gender': result['gender'],
                'age': result['age'],
                'box': [int(x) for x in result['box']]
            })
        
        return JsonResponse({
            'success': True,
            'results': serializable_results
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        })


def view_profile(request, connect_id):
    # Get the profile being viewed
    profile = get_object_or_404(UserProfile, connect_id=connect_id)
    
    # Get all related information
    profile_details = Profile.objects.filter(user=profile).first()
    education_details = EducationProfessional.objects.filter(user=profile).first()
    additional_details = AdditionalProfile.objects.filter(user=profile).first()
    family_details = Family.objects.filter(user=profile).first()
    hobbies_details = HobbiesAndLifestyle.objects.filter(user=profile).first()
    creation_details = ProfileCreationDetails.objects.filter(user=profile).first()
    
    # Get the active profile picture
    try:
        profile_picture = ProfilePicture.objects.get(user=profile, is_active=True)
    except ProfilePicture.DoesNotExist:
        profile_picture = None
    
    context = {
        'profile': profile,
        'profile_details': profile_details,
        'education_details': education_details,
        'additional_details': additional_details,
        'family_details': family_details,
        'hobbies_details': hobbies_details,
        'creation_details': creation_details,
        'profile_picture': profile_picture,  # Add the profile picture to context
    }
    
    return render(request, 'view_profile.html', context)

# views.py
from django.http import JsonResponse
from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt
import json
from .models import Interest, UserProfile

@require_POST
@csrf_exempt
def send_interest(request):
    try:
        data = json.loads(request.body)
        sender_id = data.get('sender_id')
        receiver_id = data.get('receiver_id')
        
        # Get the user profiles
        sender = UserProfile.objects.get(connect_id=sender_id)
        receiver = UserProfile.objects.get(connect_id=receiver_id)
        
        # Check if interest already exists
        if Interest.objects.filter(sender=sender, receiver=receiver).exists():
            return JsonResponse({
                'status': 'error',
                'message': 'You have already sent a request to this user'
            }, status=400)
        
        # Create and save new interest to database
        interest = Interest.objects.create(
            sender=sender,
            receiver=receiver,
            is_accepted=False  # Default value
        )
        
        # Return success response with interest details
        return JsonResponse({
            'status': 'success',
            'message': 'Request sent successfully',
            'interest_id': interest.id,
            'sent_at': interest.sent_at.isoformat()
        })
        
    except UserProfile.DoesNotExist:
        return JsonResponse({
            'status': 'error',
            'message': 'User not found'
        }, status=404)
    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': str(e)
        }, status=500)
        
def admin_page(request):
    if not request.session.get('is_admin'):
        return redirect('login_view')
    return render(request, 'admin.html')

from django.contrib.auth import logout
from django.shortcuts import redirect

def logout_view(request):
    logout(request)
    return redirect('home')  # Redirects to homepage after logout

# views.py
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from .models import Plan

def plans_list(request):
    plans = Plan.objects.filter(is_active=True)
    return render(request, 'planslist.html', {'plans': plans})

def plan_detail(request, plan_id):
    plan = get_object_or_404(Plan, pk=plan_id)
    return render(request, 'plansdetail.html', {'plan': plan})

def add_plan(request):
    if request.method == 'POST':
        # Create form handling logic here
        name = request.POST.get('name')
        duration = request.POST.get('duration')
        price = request.POST.get('price')
        description = request.POST.get('description')
        
        Plan.objects.create(
            name=name,
            duration_months=duration,
            price=price,
            description=description
        )
        return redirect('plans_list')
    
    return render(request, 'plansadd.html')


def edit_plan(request, plan_id):
    plan = get_object_or_404(Plan, pk=plan_id)
    
    if request.method == 'POST':
        plan.name = request.POST.get('name')
        plan.duration_months = request.POST.get('duration')
        plan.price = request.POST.get('price')
        plan.description = request.POST.get('description')
        plan.save()
        messages.success(request, 'Plan updated successfully!')
        return redirect('plan_detail', plan_id=plan.id)
    
    return render(request, 'plansedit.html', {'plan': plan})


from django.shortcuts import render, get_object_or_404
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import razorpay
from django.conf import settings
import json
from .models import Plan, Payment, UserProfile
from django.utils import timezone

def payment_plans(request, connect_id):
    # Get user profile using connect_id
    user_profile = get_object_or_404(UserProfile, connect_id=connect_id)
    
    plans = Plan.objects.filter(is_active=True).order_by('price')
    context = {
        'plans': plans,
        'user_profile': user_profile,
        'connect_id': connect_id
    }
    return render(request, 'payment_plans.html', context)

@csrf_exempt
def create_order(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            plan_id = data.get('plan_id')
            connect_id = data.get('connect_id')
            
            # Get user profile
            user_profile = get_object_or_404(UserProfile, connect_id=connect_id)
            
            # Get the plan
            plan = Plan.objects.get(id=plan_id)
            
            # Initialize Razorpay client
            client = razorpay.Client(auth=(settings.RAZORPAY_KEY_ID, settings.RAZORPAY_KEY_SECRET))
            
            # Create order
            order_data = {
                'amount': int(plan.price * 100),  # Convert to paise
                'currency': 'INR',
                'receipt': f'plan_{plan.id}_user_{connect_id}',
                'payment_capture': 1
            }
            order = client.order.create(order_data)
            
            return JsonResponse({
                'success': True,
                'order_id': order['id'],
                'amount': order['amount'],
                'currency': order['currency'],
                'key': settings.RAZORPAY_KEY_ID
            })
            
        except Plan.DoesNotExist:
            return JsonResponse({'success': False, 'error': 'Plan not found'}, status=404)
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)}, status=500)

@csrf_exempt
def verify_payment(request):
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            payment_id = data.get('razorpay_payment_id')
            order_id = data.get('razorpay_order_id')
            signature = data.get('razorpay_signature')
            plan_id = data.get('plan_id')
            connect_id = data.get('connect_id')
            
            # Get user profile
            user_profile = get_object_or_404(UserProfile, connect_id=connect_id)
            
            # Verify payment signature
            client = razorpay.Client(auth=(settings.RAZORPAY_KEY_ID, settings.RAZORPAY_KEY_SECRET))
            params = {
                'razorpay_order_id': order_id,
                'razorpay_payment_id': payment_id,
                'razorpay_signature': signature
            }
            
            try:
                client.utility.verify_payment_signature(params)
                
                # Get the plan
                plan = Plan.objects.get(id=plan_id)
                
                # Create payment record
                payment = Payment.objects.create(
                    user_profile=user_profile,
                    plan=plan,
                    razorpay_order_id=order_id,
                    razorpay_payment_id=payment_id,
                    razorpay_signature=signature,
                    amount=plan.price,
                    status='Completed',
                    paid_at=timezone.now()
                )
                
                return JsonResponse({
                    'success': True,
                    'message': 'Payment verified successfully',
                    'payment_id': payment.id
                })
                
            except razorpay.errors.SignatureVerificationError:
                return JsonResponse({
                    'success': False,
                    'error': 'Invalid payment signature'
                }, status=400)
                
        except Exception as e:
            return JsonResponse({
                'success': False,
                'error': str(e)
            }, status=500)

def payment_success(request, connect_id):
    # Get user profile
    user_profile = get_object_or_404(UserProfile, connect_id=connect_id)
    
    # Get the latest payment for this user
    payment = Payment.objects.filter(user_profile=user_profile).order_by('-paid_at').first()
    
    context = {
        'payment': payment,
        'user_profile': user_profile
    }
    return render(request, 'payment_success.html', context)
# views.py
from django.shortcuts import render, redirect
from django.contrib import messages
from .models import UserProfile, ProfilePicture
from .matching import Matcher

def find_matches(request, connect_id):
    try:
        # Get current user profile
        current_user = UserProfile.objects.get(connect_id=connect_id)
        
        # Get opposite gender filter
        gender_filter = 'female' if current_user.gender.lower() == 'male' else 'male'
        
        # Get potential matches (opposite gender, excluding self)
        potential_matches = UserProfile.objects.filter(
            gender__iexact=gender_filter
        ).exclude(connect_id=connect_id)
        
        # Initialize matcher and get matches (only those matching all three criteria)
        matcher = Matcher(k=10)  # Get top 10 perfect matches
        matches = matcher.get_matches(current_user, potential_matches)
        
        # Prepare match data for template
        match_data = []
        for match in matches:
            user_profile = match['user']
            match_data.append({
                'user': user_profile,
                'picture': ProfilePicture.objects.filter(
                    user=user_profile,
                    is_active=True
                ).first()
            })
        
        context = {
            'current_user': current_user,
            'matches': match_data,
            'connect_id': connect_id,
        }
        return render(request, 'matches.html', context)
    
    except UserProfile.DoesNotExist:
        messages.error(request, "User not found")
        return redirect('login')


from django.db.models import Q
from .models import UserProfile, Profile, EducationProfessional, Family, ProfilePicture

def advanced_search(request, connect_id):
    current_user = get_object_or_404(UserProfile, connect_id=connect_id)
    
    # Get all profiles (excluding current user and same gender)
    gender_filter = 'female' if current_user.gender.lower() == 'male' else 'male'
    profiles = UserProfile.objects.filter(gender__iexact=gender_filter).exclude(connect_id=connect_id)
    
    # Get all filter parameters from GET request
    marital_status = request.GET.get('marital_status')
    denomination = request.GET.get('denomination')
    education_level = request.GET.get('education_level')
    occupation = request.GET.get('occupation')
    income = request.GET.get('income')
    family_status = request.GET.get('family_status')
    
    # Build the filter query dynamically
    profile_filters = Q()
    education_filters = Q()
    family_filters = Q()
    
    # Profile filters
    if marital_status:
        profile_filters &= Q(marital_status=marital_status)
    if denomination:
        profile_filters &= Q(denomination=denomination)
    
    # Education filters
    if education_level:
        education_filters &= Q(education_level=education_level)
    if occupation:
        education_filters &= Q(occupation=occupation)
    if income:
        education_filters &= Q(annual_income=income)
    
    # Family filters
    if family_status:
        family_filters &= Q(family_status=family_status)
    
    # Apply all filters
    if profile_filters:
        profiles = profiles.filter(profile__in=Profile.objects.filter(profile_filters))
    if education_filters:
        profiles = profiles.filter(education_professional__in=EducationProfessional.objects.filter(education_filters))
    if family_filters:
        profiles = profiles.filter(family__in=Family.objects.filter(family_filters))
    
    # Get active profile pictures in one query
    profile_pictures = ProfilePicture.objects.filter(
        user__in=profiles,
        is_active=True
    ).select_related('user')
    
    # Create a mapping of user to their picture URL
    picture_map = {pic.user_id: pic.image.url for pic in profile_pictures}
    
    # Prepare profile data with picture URLs
    profile_data = []
    for profile in profiles:
        profile_data.append({
            'profile': profile,
            'picture_url': picture_map.get(profile.id),
            'marital_status': profile.profile.marital_status if hasattr(profile, 'profile') else '',
            'denomination': profile.profile.denomination if hasattr(profile, 'profile') else '',
            'education_level': profile.education_professional.education_level if hasattr(profile, 'education_professional') else '',
            'occupation': profile.education_professional.occupation if hasattr(profile, 'education_professional') else '',
            'family_status': profile.family.family_status if hasattr(profile, 'family') else ''
        })
    
    context = {
        'current_user': current_user,
        'profile_data': profile_data,
        'marital_status_choices': Profile.MARITAL_STATUS_CHOICES,
        'denomination_choices': Profile.DENOMINATION_CHOICES,
        'education_levels': EducationProfessional.EDUCATION_LEVELS,
        'occupation_choices': EducationProfessional.OCCUPATION_CHOICES,
        'income_choices': EducationProfessional.INCOME_CHOICES,
        'family_status_choices': Family.FAMILY_STATUS_CHOICES,
        'search_params': request.GET,
    }
    
    return render(request, 'advanced_search.html', context)

from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages
from django.http import JsonResponse
from .models import UserProfile, Block, ProfilePicture

def block_profile(request, connect_id, profile_id):
    if request.method == 'POST':
        blocker = get_object_or_404(UserProfile, connect_id=connect_id)
        blocked = get_object_or_404(UserProfile, connect_id=profile_id)
        
        if Block.objects.filter(blocker=blocker, blocked=blocked).exists():
            if request.headers.get('HTTP_X_REQUESTED_WITH') == 'XMLHttpRequest':
                return JsonResponse({'status': 'error', 'message': 'Already blocked'})
            messages.warning(request, 'You have already blocked this profile')
        else:
            Block.objects.create(blocker=blocker, blocked=blocked)
            if request.headers.get('HTTP_X_REQUESTED_WITH') == 'XMLHttpRequest':
                return JsonResponse({'status': 'success', 'message': 'Profile blocked'})
            messages.success(request, f'You have blocked {blocked.full_name}')
        
        return redirect('mainpage', connect_id=connect_id)
    return redirect('mainpage', connect_id=connect_id)

def unblock_profile(request, connect_id, profile_id):
    if request.method == 'POST':
        blocker = get_object_or_404(UserProfile, connect_id=connect_id)
        blocked = get_object_or_404(UserProfile, connect_id=profile_id)
        
        try:
            block = Block.objects.get(blocker=blocker, blocked=blocked)
            blocked_name = blocked.full_name
            block.delete()
        except Block.DoesNotExist:
            messages.warning(request, 'This profile was not blocked')
        
        return redirect('blocked_profiles', connect_id=connect_id)
    return redirect('mainpage', connect_id=connect_id)

def blocked_profiles(request, connect_id):
    try:
        user = get_object_or_404(UserProfile, connect_id=connect_id)
        blocked_relations = Block.objects.filter(blocker=user).select_related('blocked')
        
        blocked_profiles = []
        for relation in blocked_relations:
            profile = relation.blocked
            profile.picture = ProfilePicture.objects.filter(user=profile, is_active=True).first()
            blocked_profiles.append(profile)
        
        context = {
            'connect_id': connect_id,
            'blocked_profiles': blocked_profiles,
            'current_user': user,
        }
        return render(request, 'blocked_profiles.html', context)
    
    except UserProfile.DoesNotExist:
        messages.error(request, "User not found")
        return redirect('login')

def mainpage_view(request, connect_id):
    try:
        logged_in_user = get_object_or_404(UserProfile, connect_id=connect_id)
        profile_picture = ProfilePicture.objects.filter(user=logged_in_user, is_active=True).first()
        
        # Get blocked profile IDs
        blocked_ids = Block.objects.filter(blocker=logged_in_user).values_list('blocked__connect_id', flat=True)
        
        # Get shortlisted profile IDs
        shortlisted_ids = ShortlistedProfile.objects.filter(
            user=logged_in_user
        ).values_list('shortlisted_user__connect_id', flat=True)
        
        # Get sent interest IDs
        sent_interest_ids = Interest.objects.filter(
            sender=logged_in_user
        ).values_list('receiver__connect_id', flat=True)
        
        # Filter profiles
        profiles = UserProfile.objects.exclude(connect_id=connect_id).exclude(connect_id__in=blocked_ids)
        
        if logged_in_user.gender.lower() in ['male', 'female']:
            opposite_gender = 'female' if logged_in_user.gender.lower() == 'male' else 'male'
            profiles = profiles.filter(gender__iexact=opposite_gender)
        
        # Add profile pictures and statuses
        profiles_with_pictures = []
        for profile in profiles:
            picture = ProfilePicture.objects.filter(user=profile, is_active=True).first()
            is_shortlisted = profile.connect_id in shortlisted_ids
            request_sent = profile.connect_id in sent_interest_ids
            profile.picture_url = picture.image.url if picture else None
            profile.is_shortlisted = is_shortlisted
            profile.request_sent = request_sent
            profiles_with_pictures.append(profile)
        
        context = {
            'connect_id': connect_id,
            'profiles': profiles_with_pictures,
            'current_user': logged_in_user,
            'profile_picture': profile_picture,
        }
        return render(request, 'mainpage.html', context)
    
    except UserProfile.DoesNotExist:
        messages.error(request, "User not found")
        return redirect('login')
@require_POST
def toggle_shortlist(request, connect_id):
    try:
        current_user = UserProfile.objects.get(connect_id=connect_id)
        data = json.loads(request.body)
        profile_id = data.get('profile_id')
        action = data.get('action')
        
        if not profile_id or not action:
            return JsonResponse({'status': 'error', 'message': 'Missing parameters'}, status=400)
            
        profile_to_shortlist = UserProfile.objects.get(connect_id=profile_id)
        
        if action == 'like':
            # Create shortlist entry
            shortlist, created = ShortlistedProfile.objects.get_or_create(
                user=current_user,
                shortlisted_user=profile_to_shortlist
            )
            
            return JsonResponse({
                'status': 'success', 
                'message': 'Profile shortlisted successfully',
                'is_liked': True
            })
            
        elif action == 'unlike':
            # Remove shortlist entry
            ShortlistedProfile.objects.filter(
                user=current_user,
                shortlisted_user=profile_to_shortlist
            ).delete()
            
            return JsonResponse({
                'status': 'success',
                'message': 'Profile removed from shortlist',
                'is_liked': False
            })
            
    except UserProfile.DoesNotExist:
        return JsonResponse({'status': 'error', 'message': 'User not found'}, status=404)
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)}, status=500)
    
from django.shortcuts import redirect
from django.contrib import messages

def send_interest(request, connect_id):
    if request.method == 'POST':
        sender = get_object_or_404(UserProfile, connect_id=connect_id)
        receiver_id = request.POST.get('receiver_id')
        receiver = get_object_or_404(UserProfile, connect_id=receiver_id)
        
        # Check if interest already exists
        if Interest.objects.filter(sender=sender, receiver=receiver).exists():
            messages.info(request, 'You have already sent a request to this user')
            return redirect('mainpage', connect_id=connect_id)
        
        # Create new interest
        Interest.objects.create(sender=sender, receiver=receiver, status='pending')
        
        return redirect('mainpage', connect_id=connect_id)
    
    return redirect('mainpage', connect_id=connect_id)

from django.shortcuts import render, get_object_or_404
from django.contrib import messages
from .models import UserProfile, Interest

def view_sent_requests(request, connect_id):
    # Get the current user's profile using connect_id
    current_user = get_object_or_404(UserProfile, connect_id=connect_id)
    
    # Get all requests sent by this user with receiver details
    sent_interests = Interest.objects.filter(
        sender=current_user
    ).select_related(
        'receiver'
    ).order_by('-created_at')
    
    # Add profile pictures to each request
    for interest in sent_interests:
        interest.receiver.profile_picture = ProfilePicture.objects.filter(
            user=interest.receiver,
            is_active=True
        ).first()
    
    context = {
        'current_user': current_user,
        'sent_interests': sent_interests,  # Changed from sent_requests to sent_interests
        'request': request,  # Explicitly pass the HTTP request
    }
    return render(request, 'sent_requests.html', context)

from django.shortcuts import redirect, get_object_or_404
from django.contrib import messages
from .models import Interest

def withdraw_request(request, connect_id):
    if request.method == 'POST':
        request_id = request.POST.get('request_id')
        current_user = get_object_or_404(UserProfile, connect_id=connect_id)
        
        try:
            interest_request = Interest.objects.get(
                id=request_id,
                sender=current_user,
                status='pending'  # Only allow withdrawing pending requests
            )
            interest_request.delete()
        except Interest.DoesNotExist:
            messages.error(request, 'Request not found or cannot be withdrawn.')
        
        return redirect('view_sent_requests', connect_id=connect_id)
    
    return redirect('mainpage', connect_id=connect_id)

from django.shortcuts import render, get_object_or_404, redirect
from django.contrib import messages
from .models import UserProfile, Interest

def received_interests(request, connect_id):
    current_user = get_object_or_404(UserProfile, connect_id=connect_id)
    
    # Get all received interests with sender details
    received_interests = Interest.objects.filter(
        receiver=current_user,
        status='pending'
    ).select_related('sender').order_by('-created_at')
    
    # Add profile pictures to each interest
    for interest in received_interests:
        interest.sender.profile_picture = ProfilePicture.objects.filter(
            user=interest.sender,
            is_active=True
        ).first()
    
    context = {
        'current_user': current_user,
        'received_interests': received_interests,
    }
    return render(request, 'received_interests.html', context)

def respond_to_interest(request, connect_id):
    if request.method == 'POST':
        interest_id = request.POST.get('interest_id')
        action = request.POST.get('action')
        
        current_user = get_object_or_404(UserProfile, connect_id=connect_id)
        interest = get_object_or_404(Interest, id=interest_id, receiver=current_user)
        
        if action == 'accept':
            interest.status = 'accepted'
      # Changed from name to full_name
        elif action == 'reject':
            interest.status = 'rejected'
            # Changed from name to full_name
        
        interest.save()
        return redirect('received_interests', connect_id=connect_id)
    
    return redirect('mainpage', connect_id=connect_id)

from django.shortcuts import render
from .models import SuccessStory

def blessed_couples(request):
    approved_stories = SuccessStory.objects.filter(is_approved=True).order_by('-wedding_date')
    context = {
        'stories': approved_stories,
    }
    return render(request, 'blessed_couples.html', context)

from django.shortcuts import render

def about_contact_view(request):
    context = {
        'page_title': 'About Us & Contact',
    }
    return render(request, 'about_contact.html', context)